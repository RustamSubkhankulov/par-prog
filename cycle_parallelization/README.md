### Распараллеливание циклов

#### Условия Бернстейна

Пусть в программе имеются два оператора _S1_ и _S2_, непосредственно динамически следующих друг за другом. Пусть _W(S)_ – набор выходных переменных оператора _S_, а _R(S)_ – набор его входных переменных. Тогда возможность их одновременного выполнения различными исполнителями в параллельной системе можно определить с помощью *условий Бернстайна*.

Если для операторов _S1_ и _S2_, непосредственно динамически следующих друг за другом, выполнено:
  - пересечение _W(S1)_ и _W(S2)_ пусто;
  - пересечение _W(S1)_ и _R(S2)_ пусто;
  - пересечение _R(S1)_ и _W(S2)_ пусто;
то они могут быть исполнены параллельно. 

#### Анализ зависимостей в простых циклах

Во многих программах, связанных с математическим моделированием, приходится практически одинаковым образом обрабатывать большие массивы данных. Ввиду этого особый интерес представляет анализ существующих последовательных программ на параллелизм по данным. Распараллеливание по данным предполагает разделение массивов на зоны, каждая из которых обрабатывается отдельным исполнителем, — так называемые _зоны ответственности исполнителей_. Подобные вычисления обычно реализуется в последовательном коде с помощью операторов цикла. В работе рассматривается способ определения наличия зависимостей по данным для циклов, работающих с массивами, и влияние этих зависимостей на возможность параллельного выполнения циклов. 

Пусть тело цикла состоит из двух операторов _S1_ и _S2_, в наборы входных и/или выходных данных которых входит обращение к элементам одного и того же одномерного массива данных ``A``.
```
for (int i=0; i<i_fin; ++i) {
  S1: ...(A[f(i)])...
  S2: ... A[g(i)] ...
} 
```

Здесь ``f(i)`` и ``g(i)`` — некоторые целочисленные функции целого переменного. Для простоты будем считать, что индекс массива ``A`` может принимать любое целое значение. Нашей основной задачей является выяснение того, можно ли разбить итерационное пространство такого цикла — целочисленный отрезок ``[1, i_fin]`` — на зоны ответственности для параллельного выполнения. Вспомним, что на самом деле оператор цикла — это просто форма сокращения исходного текста программы. Если убрать это сокращение и развернуть цикл, то получим: 

```
S1,1: ...(A[f(1)])...
S2,1: ... A[g(1)] ...
S1,2: ...(A[f(2)])...
S2,2: ... A[g(2)] ...
...
S1,i_fin: ...(A[f(i_fin)])...
S2,i_fin: ... A[g(i_fin)] ...
```

В такой развернутой последовательности следующих друг за другом операторов можно провести анализ их совокупности на зависимость по данным. Будем полагать, что для одного оператора в теле цикла обращение к элементу массива A входит в набор входных переменных, а для другого — в набор выходных элементов. 

Без ограничения общности получаем цикл:
```
for (int i=0; i<i_fin; ++i) {
  S1: A[f(i)] = ...
  S2: ... = ...A[g(i)]...
}
```

Легко видеть, что условия Бернстайна могут быть нарушены в том случае, если существуют значения итерационной переменной ``i`` $\lambda$ и $\kappa$, ``1`` ≤ $\lambda$ ≤ ``i_fin``, ``1`` ≤ $\kappa$ ≤ ``i_fin`` такие, что f($\lambda$) = g($\kappa$). Чтобы узнать существуют ли такие значения, нужно решить приведенное уравнение при указанных ограничениях в целых числах. В общем случае определить, имеет ли уравнение решения, и найти их алгоритмически невозможно. 

В простых случаях, например, когда ``f`` и ``g`` — линейные функции, определить, существует ли решение, и каково оно, конечно, возможно, но в общем случае — нет. Если решения не существует, то все операторы развернутого цикла независимы друг от друга и могут быть выполнены одновременно различными исполнителями, скажем, каждая итерация цикла — на своем исполнителе. 

Пусть решение существует, и мы нашли соответствующие $\lambda$ и $\kappa$. Условия Бернстайна нарушены — между операторами есть зависимость. В этом случае оператор _S1_ (где элемент массива ``A`` — выходная переменная) называют *источником* (*source*) зависимости, а оператор _S2_ (где элемент массива ``A`` — входная переменная) называют *стоком* (*sink*) зависимости. Вычислим величину _D_ = $\lambda$ − $\kappa$ (из итерации стока вычитаем итерацию источника). Эту величину принято называть *расстоянием зависимости цикла*. 

Расстояние зависимости играет важную роль при анализе цикла на параллельность. Его значение позволяет определять тип возникающей зависимости по данным и возможность разбиения итерационного пространства на зоны ответственности для параллельного исполнения. 
  - Если расстояние зависимости _D_ < 0, то между операторами тела цикла существует *антизависимость*. Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем, если перед началом выполнения итераций продублировать необходимые входные данные на исполнителях. 
  - Если расстояние зависимости _D_ > 0, то между операторами тела цикла существует *потоковая зависимость*. При _D_ > 1 цикл может быть распараллелен не более чем на D исполнителях. 
  - Если расстояние зависимости _D_ = 0, то тип зависимости между операторами тела цикла в общем случае не определен. Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем. 

#### Анализ зависимостей во вложенных циклах
